{-# OPTIONS_GHC -Wwarn=unused-imports #-}
{-# OPTIONS_GHC -Wwarn=unused-top-binds #-}

module Main (main) where

import Data.ByteString (ByteString)
import Data.Proxy (Proxy (Proxy))
import Data.Text (Text)
import qualified Data.Text as T

import qualified Data.Map as Map
import qualified PlutusLedgerApi.V2 as V2
import Ply (AsData)
import Ply.Core.Typename (PlyTypeName, Typename (Typename), plyTypeName)

data CTLEquivalent = forall a. PlyTypeName a => CTLEquivalent Text Text (Proxy a)

ctlEquivalents :: [CTLEquivalent]
ctlEquivalents =
  [ CTLEquivalent "" "AsData" (Proxy @AsData)
  , CTLEquivalent "" "Boolean" (Proxy @Bool)
  , CTLEquivalent "Data.BigInt" "BigInt" (Proxy @Integer)
  , CTLEquivalent "Data.Unit" "Unit" (Proxy @())
  , CTLEquivalent "Ctl.Internal.Types.RawBytes" "RawBytes" (Proxy @V2.BuiltinByteString)
  , CTLEquivalent "Ctl.Internal.Types.ByteArray" "ByteArray" (Proxy @ByteString)
  , CTLEquivalent "" "String" (Proxy @Text)
  , CTLEquivalent "Ctl.Internal.Types.PlutusData" "PlutusData" (Proxy @V2.Data)
  , CTLEquivalent "Contract.Value" "Value" (Proxy @V2.Value)
  , CTLEquivalent "Contract.Address" "Address" (Proxy @V2.Address)
  , CTLEquivalent "Contract.Value" "CurrencySymbol" (Proxy @V2.CurrencySymbol)
  , CTLEquivalent "Contract.Value" "TokenName" (Proxy @V2.TokenName)
  , CTLEquivalent "Contract.Address" "PubKeyHash" (Proxy @V2.PubKeyHash)
  , CTLEquivalent "Ctl.Internal.Serialization.Hash" "ScriptHash" (Proxy @V2.ScriptHash)
  , CTLEquivalent "Contract.Time" "POSIXTime" (Proxy @V2.POSIXTime)
  , --   , CTLEquivalent "???" "DCert" (Proxy @V2.DCert)
    CTLEquivalent "Contract.Transaction" "TransactionHash" (Proxy @V2.TxId)
  , CTLEquivalent "Contract.Transaction" "TransactionInput" (Proxy @V2.TxOutRef)
  , CTLEquivalent "Contract.Transaction" "TransactionOutput" (Proxy @V2.TxOut)
  , -- , CTLEquivalent "" "(Fail (Text \"TxInInfo is not provided in CTL\"))" (Proxy @V2.TxInInfo)
    -- , CTLEquivalent "" "(Fail (Text \"TxInfo is not provided in CTL\"))" (Proxy @V2.TxInfo)
    -- , CTLEquivalent "" "(Fail (Text \"ScriptPurpose is not provided in CTL\"))" (Proxy @V2.ScriptPurpose)
    -- , CTLEquivalent "" "(Fail (Text \"ScriptContext is not provided in CTL\"))" (Proxy @V2.ScriptContext)
    CTLEquivalent "Ctl.Internal.Types.Datum" "Datum" (Proxy @V2.Datum)
  , --  , CTLEquivalent "Ctl.Internal.Types.Datum" "Datum" (Proxy @V2.Redeemer)
    CTLEquivalent "Ctl.Internal.Types.Transaction" "DataHash" (Proxy @V2.DatumHash)
  , CTLEquivalent "Ctl.Internal.Types.Redeemer" "RedeemerHash" (Proxy @V2.RedeemerHash)
  ]

genInstance :: CTLEquivalent -> Text
genInstance (CTLEquivalent _ n (_ :: Proxy a)) =
  let (Typename tName) = plyTypeName @a
   in "instance PlyTypeName " <> n <> " where plyTypeName _ = \"" <> tName <> "\""

genInstances :: [CTLEquivalent] -> Text
genInstances c = T.intercalate "\n" $ genInstance <$> c

genImports :: [(Text, Text)] -> Text
genImports c = Map.foldMapWithKey mkImportStatement importList
  where
    mkImportStatement "" _ = ""
    mkImportStatement m ts =
      "import " <> m <> " (" <> T.intercalate "," ts <> ")\n"
    importList = foldr go Map.empty c
    go (m, t) =
      Map.insertWith (<>) m [t]

genCTLImports :: [CTLEquivalent] -> Text
genCTLImports = genImports . fmap (\(CTLEquivalent m ts _) -> (m, ts))

gen :: [CTLEquivalent] -> Text
gen c =
  T.intercalate
    "\n"
    [ "{-"
    , "This file is generated by `genPurs` in order to embedded serialized type"
    , "names used by `ply-core`, which uses GHC's `Typeable`."
    , "-}"
    , "module Ply.Typename (class PlyTypeName, plyTypeName) where"
    , " "
    , genImports
        [ ("Type.Proxy", "Proxy (Proxy)")
        , ("Prelude", "(<>)")
        , ("Ply.Types", "AsData")
        ]
    , " "
    , genCTLImports c
    , " "
    , "class PlyTypeName :: forall k. k -> Constraint"
    , "class PlyTypeName a where"
    , "  plyTypeName :: Proxy a -> String  "
    , " "
    , genInstances ctlEquivalents
    , " "
    , "-- Instance for Algebric Data Types"
    , "instance (PlyTypeName a, PlyTypeName b) => PlyTypeName (a b) where"
    , "  plyTypeName _ = plyTypeName (Proxy :: Proxy a) <> \"#\" <> plyTypeName (Proxy :: Proxy b)"
    ]

main :: IO ()
main = do
  putStrLn $ T.unpack $ gen ctlEquivalents
