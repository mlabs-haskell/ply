{-# OPTIONS_GHC -Wwarn=unused-imports #-}
{-# OPTIONS_GHC -Wwarn=unused-top-binds #-}

{- | GenPurs generates Purescript modules `Ply.Typename` that allows
     interfacing between ply-core and ply-ctl. Essentially, it writes
     "lookup" typeclasses that ply-ctl can use to resolve types
     from `TypedEnvelope` into equivalent CTL types to accomplish same
     degree of type safety in the CTL(Plutonomicon/cardano-transaction-lib).

     Why codegen? Purescript does not provide runtime type reflection,
     so it's the only way to get quasi type reflection in Purescript.

     Any new types, not generated by genPurs, can be added easily by
     implementing `PlyTypeName` class.
-}
module Main (main) where

import Data.ByteString (ByteString)
import Data.Proxy (Proxy (Proxy))
import Data.Text (Text)
import qualified Data.Text as T

import qualified Data.Map as Map
import qualified PlutusLedgerApi.V2 as V2
import Ply (AsData)
import Ply.Core.Typename (PlyTypeName, Typename (Typename), plyTypeName)

data CTLEquivalent = forall a. PlyTypeName a => CTLEquivalent Text Text (Proxy a)

ctlEquivalents :: [CTLEquivalent]
ctlEquivalents =
  [ CTLEquivalent "" "AsData" (Proxy @AsData)
  , CTLEquivalent "" "Boolean" (Proxy @Bool)
  , CTLEquivalent "Data.BigInt" "BigInt" (Proxy @Integer)
  , CTLEquivalent "Data.Unit" "Unit" (Proxy @())
  , CTLEquivalent "Ctl.Internal.Types.RawBytes" "RawBytes" (Proxy @V2.BuiltinByteString)
  , CTLEquivalent "Ctl.Internal.Types.ByteArray" "ByteArray" (Proxy @ByteString)
  , CTLEquivalent "" "String" (Proxy @Text)
  , CTLEquivalent "Ctl.Internal.Types.PlutusData" "PlutusData" (Proxy @V2.Data)
  , CTLEquivalent "Contract.Value" "Value" (Proxy @V2.Value)
  , CTLEquivalent "Contract.Address" "Address" (Proxy @V2.Address)
  , CTLEquivalent "Contract.Value" "CurrencySymbol" (Proxy @V2.CurrencySymbol)
  , CTLEquivalent "Contract.Value" "TokenName" (Proxy @V2.TokenName)
  , CTLEquivalent "Contract.Address" "PubKeyHash" (Proxy @V2.PubKeyHash)
  , CTLEquivalent "Ctl.Internal.Serialization.Hash" "ScriptHash" (Proxy @V2.ScriptHash)
  , CTLEquivalent "Contract.Time" "POSIXTime" (Proxy @V2.POSIXTime)
  , --   , CTLEquivalent "???" "DCert" (Proxy @V2.DCert)
    CTLEquivalent "Contract.Transaction" "TransactionHash" (Proxy @V2.TxId)
  , CTLEquivalent "Contract.Transaction" "TransactionInput" (Proxy @V2.TxOutRef)
  , CTLEquivalent "Contract.Transaction" "TransactionOutput" (Proxy @V2.TxOut)
  , -- , CTLEquivalent "" "(Fail (Text \"TxInInfo is not provided in CTL\"))" (Proxy @V2.TxInInfo)
    -- , CTLEquivalent "" "(Fail (Text \"TxInfo is not provided in CTL\"))" (Proxy @V2.TxInfo)
    -- , CTLEquivalent "" "(Fail (Text \"ScriptPurpose is not provided in CTL\"))" (Proxy @V2.ScriptPurpose)
    -- , CTLEquivalent "" "(Fail (Text \"ScriptContext is not provided in CTL\"))" (Proxy @V2.ScriptContext)
    CTLEquivalent "Ctl.Internal.Types.Datum" "Datum" (Proxy @V2.Datum)
  , --  , CTLEquivalent "Ctl.Internal.Types.Datum" "Datum" (Proxy @V2.Redeemer)
    CTLEquivalent "Ctl.Internal.Types.Transaction" "DataHash" (Proxy @V2.DatumHash)
  , CTLEquivalent "Ctl.Internal.Types.Redeemer" "RedeemerHash" (Proxy @V2.RedeemerHash)
  ]

genInstance :: CTLEquivalent -> Text
genInstance (CTLEquivalent _ n (_ :: Proxy a)) =
  let (Typename tName) = plyTypeName @a
   in "instance PlyTypeName " <> n <> " where plyTypeName _ = \"" <> tName <> "\""

genInstances :: [CTLEquivalent] -> Text
genInstances c = T.unlines $ genInstance <$> c

genImports :: [(Text, Text)] -> Text
genImports c = Map.foldMapWithKey mkImportStatement importList
  where
    mkImportStatement "" _ = ""
    mkImportStatement m ts =
      "import " <> m <> " (" <> T.intercalate "," ts <> ")\n"
    importList = foldr go Map.empty c
    go (m, t) = Map.insertWith (<>) m [t]

genCTLImports :: [CTLEquivalent] -> Text
genCTLImports = genImports . fmap (\(CTLEquivalent m ts _) -> (m, ts))

gen :: [CTLEquivalent] -> Text
gen c =
  T.unlines
    [ "{-"
    , "This file is generated by `genPurs` in order to embedded serialized type"
    , "names used by `ply-core`, which uses GHC's `Typeable`."
    , "-}"
    , "module Ply.Typename (class PlyTypeName, plyTypeName) where"
    , " "
    , genImports
        [ ("Type.Proxy", "Proxy (Proxy)")
        , ("Prelude", "(<>)")
        , ("Ply.Types", "AsData")
        ]
    , " "
    , genCTLImports c
    , " "
    , "class PlyTypeName :: forall k. k -> Constraint"
    , "class PlyTypeName a where"
    , "  plyTypeName :: Proxy a -> String  "
    , " "
    , genInstances ctlEquivalents
    , " "
    , "-- Instance for Algebric Data Types"
    , "instance (PlyTypeName a, PlyTypeName b) => PlyTypeName (a b) where"
    , "  plyTypeName _ = plyTypeName (Proxy :: Proxy a) <> \"#\" <> plyTypeName (Proxy :: Proxy b)"
    ]

main :: IO ()
main = do
  putStrLn $ T.unpack $ gen ctlEquivalents
